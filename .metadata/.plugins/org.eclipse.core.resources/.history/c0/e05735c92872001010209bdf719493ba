#include "usart_driver.h"
#include <stddef.h>

void USART_Init(USART_TypeDef *USARTx, USART_InitTypeDef *init) {
    // Disable USART before configuration
    USARTx->CR1 &= ~USART_CR1_UE;

    // Configure baud rate
    // Assuming 16MHz clock (adjust this based on your system clock)
    uint32_t usartdiv = (16000000 + (init->BaudRate / 2)) / init->BaudRate;
    USARTx->BRR = usartdiv;

    // Configure word length
    if (init->WordLength == USART_WORDLENGTH_9B) {
        USARTx->CR1 |= (1 << 12); // M bit set
    } else {
        USARTx->CR1 &= ~(1 << 12); // M bit clear
    }

    // Configure stop bits
    USARTx->CR2 &= ~(0x3 << 12); // Clear stop bits
    switch (init->StopBits) {
        case USART_STOPBITS_1:
            // Default (00) is 1 stop bit
            break;
        case USART_STOPBITS_0_5:
            USARTx->CR2 |= (1 << 12); // STOP0.5
            break;
        case USART_STOPBITS_2:
            USARTx->CR2 |= (2 << 12); // STOP2
            break;
    }

    // Configure parity
    USARTx->CR1 &= ~((1 << 9) | (1 << 10)); // Clear PCE and PS bits
    switch (init->Parity) {
        case USART_PARITY_NONE:
            // No parity (default)
            break;
        case USART_PARITY_EVEN:
            USARTx->CR1 |= (1 << 10); // PCE=1, PS=0 (even parity)
            break;
        case USART_PARITY_ODD:
            USARTx->CR1 |= (1 << 10) | (1 << 9); // PCE=1, PS=1 (odd parity)
            break;
    }

    // Configure hardware flow control
    USARTx->CR3 &= ~((1 << 8) | (1 << 9)); // Clear RTSE and CTSE bits
    switch (init->HWFlowControl) {
        case USART_HWCONTROL_NONE:
            // Default (no flow control)
            break;
        case USART_HWCONTROL_RTS:
            USARTx->CR3 |= (1 << 8); // RTSE=1
            break;
        case USART_HWCONTROL_CTS:
            USARTx->CR3 |= (1 << 9); // CTSE=1
            break;
        case USART_HWCONTROL_RTS_CTS:
            USARTx->CR3 |= (1 << 8) | (1 << 9); // RTSE=1, CTSE=1
            break;
    }

    // Configure mode (TX/RX)
    USARTx->CR1 &= ~(USART_CR1_TE | USART_CR1_RE);
    USARTx->CR1 |= init->Mode;

    // Enable USART
    USARTx->CR1 |= USART_CR1_UE;
}

void USART_Enable(USART_TypeDef *USARTx) {
    USARTx->CR1 |= USART_CR1_UE;
}

void USART_Disable(USART_TypeDef *USARTx) {
    USARTx->CR1 &= ~USART_CR1_UE;
}

void USART_SendData(USART_TypeDef *USARTx, uint16_t data) {
    // Wait until transmit data register is empty
    while (!(USARTx->ISR & USART_ISR_TXE));

    // Write data to transmit data register
    USARTx->TDR = (data & 0x01FF);
}

uint16_t USART_ReceiveData(USART_TypeDef *USARTx) {
    // Wait until data is received
    while (!(USARTx->ISR & USART_ISR_RXNE));

    // Check for overrun error
    if (USARTx->ISR & USART_ISR_ORE) {
        USART_ClearFlag(USARTx, USART_ICR_ORECF);
    }

    // Return received data
    return (USARTx->RDR & 0x01FF);
}

void USART_SendString(USART_TypeDef *USARTx, const char *str) {
    while (*str) {
        USART_SendData(USARTx, *str++);
    }
}

void USART_EnableInterrupt(USART_TypeDef *USARTx, uint32_t interrupt) {
    USARTx->CR1 |= interrupt;
}

void USART_DisableInterrupt(USART_TypeDef *USARTx, uint32_t interrupt) {
    USARTx->CR1 &= ~interrupt;
}

void USART_ClearFlag(USART_TypeDef *USARTx, uint32_t flag) {
    USARTx->ICR = flag;
}

uint8_t USART_GetFlagStatus(USART_TypeDef *USARTx, uint32_t flag) {
    return ((USARTx->ISR & flag) != 0) ? 1 : 0;
}
