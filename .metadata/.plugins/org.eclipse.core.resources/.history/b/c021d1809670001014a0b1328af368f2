
#include "RCC_private.h"
#include <stdint.h>

void RCC_vSetClkSts(uint8_t Copy_u8CLK, uint8_t Copy_u8Status)
{
  if (Copy_u8CLK == HSI_CLK)
  {
    if (Copy_u8Status == CLK_ON)
    {
      MRCC_t->CR |= (1 << 0);  // Enable HSI
      while((MRCC_t->CR & (1 << 1)) == 0); // Wait for HSIRDY
    }
    else if (Copy_u8Status == CLK_OFF)
    {
      MRCC_t->CR &= ~(1 << 0);  // Disable HSI
      while((MRCC_t->CR & (1 << 1)) != 0); // Wait until off
    }
  }
  else if (Copy_u8CLK == HSE_CLK)
  {
    if (Copy_u8Status == CLK_ON)
    {
      MRCC_t->CR |= (1 << 18); // Enable HSE bypass if needed
      MRCC_t->CR |= (1 << 16); // Enable HSE
      while((MRCC_t->CR & (1 << 17)) == 0); // Wait for HSERDY
    }
    else if (Copy_u8Status == CLK_OFF)
    {
      MRCC_t->CR &= ~(1 << 16); // Disable HSE
      while((MRCC_t->CR & (1 << 17)) != 0); // Wait until off
    }
  }
  else if (Copy_u8CLK == PLL_CLK)
  {
    if (Copy_u8Status == CLK_ON)
    {
      MRCC_t->CR |= (1 << 24); // Enable PLL
      while((MRCC_t->CR & (1 << 25)) == 0); // Wait for PLLRDY
    }
    else if (Copy_u8Status == CLK_OFF)
    {
      MRCC_t->CR &= ~(1 << 24); // Disable PLL
      while((MRCC_t->CR & (1 << 25)) != 0); // Wait until off
    }
  }
}

void RCC_vSetSysClk(uint8_t Copy_u8CLK)
{
  MRCC_t->CFGR &= ~(0x3);       // Clear clock source bits
  MRCC_t->CFGR |= Copy_u8CLK;   // Set new clock source
}

void RCC_vPLLConfig(uint8_t Copy_u8PLLSrc, uint8_t Copy_u8PLLMul)
{
  // Configure PLL source (HSI/HSE)
  if (Copy_u8PLLSrc == PLL_HSI)
    MRCC_t->CFGR &= ~(1 << 16);
  else if (Copy_u8PLLSrc == PLL_HSE || Copy_u8PLLSrc == PLL_HSE_DIV_2)
  {
    MRCC_t->CFGR |= (1 << 16);
    if (Copy_u8PLLSrc == PLL_HSE_DIV_2)
      MRCC_t->CFGR |= (1 << 17);
    else
      MRCC_t->CFGR &= ~(1 << 17);
  }

  // Set PLL multiplier
  MRCC_t->CFGR &= ~(0xF << 18);  // Clear multiplier bits
  MRCC_t->CFGR |= (Copy_u8PLLMul << 18);
}

void RCC_vAHBConfig(uint8_t Copy_u8AHPDiv)
{
  MRCC_t->CFGR &= ~(0xF << 4);   // Clear AHB prescaler bits
  MRCC_t->CFGR |= (Copy_u8AHPDiv << 4);
}

void RCC_vAPB1Config(uint8_t Copy_u8APB1Div)
{
  MRCC_t->CFGR &= ~(0x7 << 8);   // Clear APB1 prescaler bits
  MRCC_t->CFGR |= (Copy_u8APB1Div << 8);
}

void RCC_vAPB2Config(uint8_t Copy_u8APB2Div)
{
  MRCC_t->CFGR &= ~(0x7 << 11);  // Clear APB2 prescaler bits
  MRCC_t->CFGR |= (Copy_u8APB2Div << 11);
}

void RCC_vAHPPerSts(uint8_t Copy_u8AHPPer, uint8_t Copy_u8Status)
{
  if (Copy_u8Status == PER_ON)
    MRCC_t->AHPENR |= (1 << Copy_u8AHPPer);
  else if (Copy_u8Status == PER_OFF)
    MRCC_t->AHPENR &= ~(1 << Copy_u8AHPPer);
}

void RCC_vABPPerSts(uint8_t Copy_u8Bus, uint8_t Copy_u8AHPPer, uint8_t Copy_u8Status)
{
  if (Copy_u8Bus == APB1)
  {
    if (Copy_u8Status == PER_ON)
      MRCC_t->APB1ENR |= (1 << Copy_u8AHPPer);
    else if (Copy_u8Status == PER_OFF)
      MRCC_t->APB1ENR &= ~(1 << Copy_u8AHPPer);
  }
  else if (Copy_u8Bus == APB2)
  {
    if (Copy_u8Status == PER_ON)
      MRCC_t->APB2ENR |= (1 << Copy_u8AHPPer);
    else if (Copy_u8Status == PER_OFF)
      MRCC_t->APB2ENR &= ~(1 << Copy_u8AHPPer);
  }
}
